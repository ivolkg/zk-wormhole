// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    WORMHOLE_ELF, WORMHOLE_ID
};
use risc0_zkvm::{default_prover, ExecutorEnv};
use risc0_zkvm::Receipt;

fn wormhole() -> Receipt {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    env_logger::init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let nullifier = [0_u8; 32];
    let secret = [1_u8; 32];
    let amount = 100_u64;
    let balance = 1000_u64;
    let state_root = [2_u8; 32];
    let sender_addr = [3_u8; 20];
    let env = ExecutorEnv::builder()
    .write(&nullifier)
    .unwrap()
    .write(&secret)
    .unwrap()
    .write(&amount)
    .unwrap()
    .write(&balance)
    .unwrap()
    .write(&state_root)
    .unwrap()
    .write(&sender_addr)
    .unwrap()
    .build().unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove_elf(env, WORMHOLE_ELF).unwrap();
    receipt
}
fn main() {

    // TODO: Implement code for retrieving receipt journal here.

    let receipt = wormhole();
    // For example:
    let _output: u32 = receipt.journal.decode().unwrap();

    // Optional: Verify receipt to confirm that recipients will also be able to
    // verify your receipt
    receipt.verify(WORMHOLE_ID).unwrap();
}
